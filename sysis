#!/bin/bash

# sysis - Collect and print information on system, network and OS
#
#     For OSX & Linux
#         tested on yosemite, Debian Linux, Raspbian (Debian on Rasberry Pi)
#
#   TO DO -
#     Shorten commands using awk
#     enhance error checking - before ALL shell commands
#       set EXITSTATUS & EXITMESSAGE accordingly

# INIT VARS AND FUNCTIONS
scriptname="sysis"
scriptbuildnum="3.3.13"
scriptbuilddate="2016-05-31"

############################################################
### VARS INITS

OS=$(uname -s)
MACHINE_NAME=$(hostname -s)

# VARIABLES - OTHER
REPORTTITLE="System Information"
EXITSTATUS=0
EXITMESSAGE=""


############################################################
###     PRE-EXECUTION

# TURN ON COLOR IF POSSIBLE, SET THEME
if test -t 1; then            # check if stdout is a terminal
    ncolors=$(tput colors)    # see if it supports colors
    if test -n "$ncolors" && test $ncolors -ge 8; then
      # Set Colors
        bold="$(tput bold)"
        underline="$(tput smul)"
        standout="$(tput smso)"
        normal="$(tput sgr0)"
        black="$(tput setaf 0)"
        red="$(tput setaf 1)"
        green="$(tput setaf 2)"
        yellow="$(tput setaf 3)"
        blue="$(tput setaf 4)"
        magenta="$(tput setaf 5)"
        cyan="$(tput setaf 6)"
        white="$(tput setaf 7)"

      # Set Color Theme - vars used by echo statements
        CLRnormal="\033[0m"
        CLRwhite=${bold}${white}
        CLRheading=${bold}${blue}
        # CLRheading=${bold}${green}
        CLRheading2=${bold}${green}
        # CLRheading2=${bold}${blue}
        CLRtitle=${bold}${cyan}
        CLRtitle2=${bold}${magenta}
        CLRsuccess=${bold}${green}
        CLRwarning=${bold}${yellow}
        CLRerror=${bold}${red}
    fi
fi


######################################################################
#     FUNCTIONS
######################################################################

processExit () {    # ERROR MESSAGE CAN BE SENT TO FUNCTION WHEN CALLING
  local var="$*"
  if [[ -n "$EXITMESSAGE" ]]; then
    echo -e "$EXITMESSAGE" >&2
  fi
  if [[ -n "$var" ]]; then
    echo -e "$var" >&2
    [[ "$EXITSTATUS" == 0 ]] && EXITSTATUS=1  # if error-text passed set to at least 1
  fi
  exit $EXITSTATUS
}

processAbort () {
  local var=$*
  [[ -n $var ]] && EXITMESSAGE="${CLRerror}ABORT${CLRwhite} - ${var}${CLRnormal}"
  EXITSTATUS=2
  processExit
}

display_ver() {
  echo -en "${CLRheading2}${scriptname}${CLRwhite}  ver ${CLRtitle}${scriptbuildnum} ${CLRwhite}- ${CLRtitle}${scriptbuilddate}${CLRwhite}${CLRnormal}"
}

printScriptHelpInfo() {
  display_ver
  echo -e "\n${CLRwhite}Collect and print information on system, network and OS to standard output.\n"
  echo -e "${CLRtitle}usage: ${CLRwhite}${scriptname} ${CLRtitle2}[OPTIONS] [DEBUG]${CLRwhite}\n"
  echo -e "${CLRtitle}   OPTIONS"
  echo -e "${CLRtitle2}     -d\t${CLRwhite}: debug only report"
  echo -e "${CLRtitle2}     -n\t${CLRwhite}: network only report"
  echo -e "${CLRtitle2}     -h\t${CLRwhite}: basic help"
  echo -e "${CLRtitle2} --help\t${CLRwhite}: detailed help${CLRnormal}"
  if [[ "$1" ]]; then   # print all help
    echo
    echo -e "${CLRtitle}   DEBUG"
    echo -e "${CLRtitle2}--force\t${CLRwhite}: force report as 'unknown' type"
    echo
    echo -e "${CLRtitle}   EXIT STATUS"
    echo -e "${CLRtitle2}      0   ${CLRwhite}if OK,"
    echo -e "${CLRtitle2}      1   ${CLRwhite}if minor problems (e.g., cannot access subdirectory),"
    echo -e "${CLRtitle2}      2   ${CLRwhite}if serious trouble (e.g., cannot access command-line argument).${CLRnormal}"
  fi
  processExit
}

processCommandTail() {
  while [[ -n $1 ]]; do
    case $1 in
      -d)           mode="DEBUG";;
      -n)           mode="NET";;
      -h)           printScriptHelpInfo;;
      -V)           display_ver; exit 0;;
      --help)       printScriptHelpInfo FULL;;
      --force)      mode="FORCE";;
      *)            printScriptHelpInfo;;
    esac
    shift
  done
  return 0
}

gatherPUBLICip() {
	pubIP=$(curl -s ipinfo.io/ip)
  return 0
}

gatherLANip() {
	case $OS in
   Linux) # note RPI only has awk 1.x installed
    lanIP=$(ifconfig -a | awk '/(cast)/ {print $2}' | cut -d: -f2) ;;
   Darwin)  # filters virtual adapters by checking for broadcast addy's with limited scope
    lanIP=$(ifconfig -a | awk '/(cast).([0-9]{1,3}\.){2}1\./ {print $2}') ;;
   FreeBSD|OpenBSD)
    lanIP=$(ifconfig  | grep -E 'inet.[0-9]' | grep -v '127.0.0.1' | awk '{print $2}') ;;
   SunOS)
    lanIP=$(ifconfig -a | grep inet | grep -v '127.0.0.1' | awk '{print $2}') ;;
   *)
    lanIP="Unknown" ;;
	esac
  if [[ -n $lanIP ]]; then
		count=0
		for i in $lanIP; do     # IF MULTI-IP's PUT IN ARRAY
			lanIPS[count]=$i
			((++count))
		done
	fi
  return 0
}

gatherSYSinfo() {
  if [[ $(uname 2> /dev/null) ]]; then
  	SYSnode=$(uname -n 2> /dev/null)
  	SYSkernal=$(uname -s 2> /dev/null)
  	SYSkernalVer=$(uname -r 2> /dev/null)
  	SYSmachine=$(uname -m 2> /dev/null)
  	SYSplatform=$(uname -i 2> /dev/null)
  else
    processExit "cannot execute 'uname'"
  fi
  return 0
}

gatherARCHinfo() {
  if [[ $(dpkg --help 2> /dev/null) ]]; then
    PROCarch=$(dpkg --print-architecture) # on RPI2, and RPI-Zero = armhf
  fi
  return 0
}

trim() {
    local var=$*
    var="${var%"${var##*[![:space:]]}"}"  # remove leading whitespace
    var="${var#"${var%%[![:space:]]*}"}"  # remove trailing whitespace
    echo -n "$var"
}

gatherLSBinfo() {
  if [[ $(lsb_release -h 2> /dev/null) ]]; then
    LSBset="TRUE"   # LSB AVAILABLE FLAG
    LSBidPRE=$(lsb_release -i 2> /dev/null)
    LSBdescrPRE=$(lsb_release -d 2> /dev/null)
    LSBrelPRE=$(lsb_release -r 2> /dev/null)
    LSBcodenamePRE=$(lsb_release -c 2> /dev/null)
    LSBallPRE=$(lsb_release -a 2> /dev/null)
    # Clean up text
  	[[ -n $LSBidPRE ]] && LSBid=${LSBidPRE#*":"} && LSBid=$(trim "$LSBid")
  	[[ -n $LSBdescrPRE ]] && LSBdescr=${LSBdescrPRE#*":"} && LSBdescr=$(trim "$LSBdescr")
  	[[ -n $LSBrelPRE ]] && LSBrel=${LSBrelPRE#*":"} && LSBrel=$(trim "$LSBrel")
  	[[ -n $LSBcodenamePRE ]] && LSBcodename=${LSBcodenamePRE#*":"} && LSBcodename=$(trim "$LSBcodename")
   	[[ -n $LSBallPRE ]] && LSBall=${LSBallPRE#*":"} && LSBall=$(trim "$LSBall")
  fi
  return 0
}

setNOTOSXvars() {
  if [[ $LSBset == "TRUE" ]]; then
    OSfullname="${LSBid} ${SYSkernal} ${LSBrel}"
    OScodename="${LSBcodename}"
  else  # lsb_release not installed
    if [ -e "/etc/*release" ]; then # if it exists - set OS info from release doc
      OSrelease=$(awk '/^VERSION_ID=/ {split($1, ary, /"/); print ary[2]}' /etc/*release)
      OSfullname="$(awk '/^ID=/ { print toupper(substr($name,4,1)) tolower(substr($name,5))}' /etc/*release) ${SYSkernal} ${OSrelease}"
      OScodename=$(awk '/^VERSION=/ {split($0, ary, /(\()||(\))/); print toupper(substr(ary[2],1,1)) tolower(substr(ary[2],2)) }' /etc/*release)
    else  # no OS release doc, just use the basic OS name from uname
      OSfullname="${SYSkernal}"
    fi
  fi
  return 0
}

setLinuxCommon() {
  setNOTOSXvars
  if [ -e "/sys/devices/system/cpu/possible" ]; then
    CPUspeed=$(lscpu | grep -m1 'MHz')
      CPUspeed=${CPUspeed%.*}             # strip eVERythign right of '.'
      CPUspeed=${CPUspeed#*:}             # strip eVERything left of ':'
      CPUspeed=${CPUspeed// /}            # strip spaces
      CPUspeedBig=$((CPUspeed / 1000))    # main digit
      CPUspeedSmall=$((CPUspeed % 1000))  # sub digit
      CPUspeed="${CPUspeedBig}.${CPUspeedSmall:0:1} GHz"
    CPUcores=$(lscpu | grep 'Core(s)')
      CPUcores=${CPUcores#*:}             # strip left of ': '
      CPUcores=${CPUcores// /}            # strip spaces
  fi
  DISKusage=$(df -h | awk '$NF=="/"{printf "%d/%d GB (%s)\n", $3,$2,$5}')
  return 0
}

setRPIvars() {
  DeviceType="RPI"
  setLinuxCommon
  RPIrev=$(awk '/Revision/ { sub(/^.+\:/, "") ; print $1 }' /proc/cpuinfo)
  # info: http://elinux.org/RPi_HardwareHistory
  case "$RPIrev" in
      *beta) RPImodel="Beta"; RPImem="256 MB"; RPIman="Beta"; RPIrel="Q1 2012";;
      *002) RPImodel="B (1.0)"; RPImem="256 MB"; RPIman="unknown"; RPIrel="Q1 2012";;
      *003) RPImodel="B (1.0)"; RPImem="256 MB"; RPIman="ECN 001"; RPIrel="Q3 2012";;
      *004) RPImodel="B (2.0)"; RPImem="256 MB"; RPIman="Sony"; RPIrel="Q3 2012";;
      *005) RPImodel="B (2.0)"; RPImem="256 MB"; RPIman="Qisda"; RPIrel="Q4 2012";;
      *006) RPImodel="B (2.0)"; RPImem="256 MB"; RPIman="Egoman"; RPIrel="Q4 2012";;
      *007) RPImodel="A (2.0)"; RPImem="256 MB"; RPIman="Egoman"; RPIrel="Q1 2013";;
      *008) RPImodel="A (2.0)"; RPImem="256 MB"; RPIman="Sony"; RPIrel="Q1 2013";;
      *009) RPImodel="A (2.0)"; RPImem="256 MB"; RPIman="Qisda"; RPIrel="Q1 2013";;
      *00d) RPImodel="B (2.0)"; RPImem="512 MB"; RPIman="Egoman"; RPIrel="Q4 2012";;
      *00e) RPImodel="B (2.0)"; RPImem="512 MB"; RPIman="Sony"; RPIrel="Q4 2012";;
      *00f) RPImodel="B (2.0)"; RPImem="512 MB"; RPIman="Qisda"; RPIrel="Q4 2012";;
      *010) RPImodel="B+ (1.0)"; RPImem="512 MB"; RPIman="Sony"; RPIrel="Q3 2014";;
      *011) RPImodel="Compute Module"; RPImem="512 MB"; RPIman="Sony"; RPIrel="Q2 2014";;
      *012) RPImodel="A+ (1.0)"; RPImem="256 MB"; RPIman="Sony"; RPIrel="Q4 2014";;
      *013) RPImodel="B+ (1.2)"; RPImem="512 MB"; RPIman="Embest"; RPIrel="Q1 2015";;
      *014) RPImodel="Compute Module"; RPImem="512 MB"; RPIman="Sony"; RPIrel="Q1 2015";;
      *015) RPImodel="A+ (1.0)"; RPImem="256 MB"; RPIman="Sony"; RPIrel="Q1 2015";;
      *a01041) RPImodel="2B (1.1)"; RPImem="1 GB"; RPIman="Sony"; RPIrel="Q1 2015";;
      *a21041) RPImodel="2B (1.1)"; RPImem="1 GB"; RPIman="Embest"; RPIrel="Q1 2015";;
      *900092) RPImodel="Zero (2.0)"; RPImem="512 MB"; RPIman="Sony"; RPIrel="Q4 2015";;
      *a02082) RPImodel="3B (1.2)"; RPImem="1 GB"; RPIman="Sony"; RPIrel="Q1 2016";;
      *) RPImodel="'Unknown Version'"; RPImem="Unknown"; RPIman="Unknown"; RPIrel="Unknown";;
  esac
  # OSfullname in setLinuxCommon - setNOTOSXvars
  # OScodename in setLinuxCommon - setNOTOSXvars
  OSVERsion=${SYSkernalVer%"-"*}  #remove '-xxx' on right
  HWdevice="Raspberry Pi ${RPImodel}"
  HWrelease="${RPIrel} (${RPIman})"
  CPUname=$(awk '/model\ name/ { sub(/-compatible/, ""); print ($4)" r"($7); exit}' /proc/cpuinfo)
  # CPUspeed set in setLinuxCommon
  # CPUcores set in setLinuxCommon
  MEMsize="${RPImem}"
  MEMusage=$(free -m | awk 'NR==2{printf "%s/%s MB (%d%%)\n", $3,$2,$3*100/$2 }')
  # DISKusage set in setLinuxCommon
  return 0
}

setLINUXvars() {
  DeviceType="Linux"
  setLinuxCommon
  # OSfullname in setLinuxCommon - setNOTOSXvars
  # OScodename in setLinuxCommon - setNOTOSXvars
  OSVERsion=${SYSkernalVer%%"-"*}  #remove '-amd64' on right
  HWdevice="" # UNKNOWN HW
  HWrelease=""  # UNKNOWN HW
  CPUname=$(grep -m1 'model name' < /proc/cpuinfo)
    CPUname=${CPUname#*': '} # strip eVERything left of ': '
    CPUname=${CPUname//'(R)'/} # remove '(R)'
    CPUname=${CPUname//'(tm)'/} # remove '(tm)'
    CPUname=${CPUname/' CPU'/} # remove ' CPU'
    CPUname=${CPUname/' Processor'/} # remove ' Processor'
    CPUname=${CPUname%' @'*} # remove eVERything right of ' @', thus removing speed
  # CPUspeed set in setLinuxCommon
  # CPUcores set in setLinuxCommon
  MEMraw=$(free -m | awk '/^Mem:/{print $2}')
    MEMsize=$(( MEMraw / 925 ))   # total system ram in GB
    MEMsize="${MEMsize} GB"
  MEMusage=$(free -m | awk 'NR==2{printf "%s/%s MB (%.0f%%)\n", $3,$2,$3*100/$2 }')
  # DISKusage set in setLinuxCommon
  return 0
}

setOSXvars() {
  DeviceType="OSX"
  OSXinitialVer=${SYSkernalVer%%.*} # remove eVERything right of first '.'
  OSXadjustedVer=$((OSXinitialVer-4))  # subtract 4 from first number
  OSXsubVer=${SYSkernalVer%.*}  # remove rightmost # - 14.5.0 to 14.5
  OSXsubVer=${OSXsubVer#*.} # move leftmost # - 14.5 to 5
  OSXmainVer="10.${OSXadjustedVer}"
  OSVERsion="10.${OSXadjustedVer}.${OSXsubVer}"
  OSfullname="OS X ${OSXmainVer}"
  # OSfullname="OS X ${OSXmainVer}"
  case $OSXmainVer in
    10.11) OScodename="El Capitan";;
    10.10) OScodename="Yosemite";;
    10.9) OScodename="MaVERicks";;
    10.8) OScodename="Mountain Lion";;
    10.7) OScodename="Lion";;
    10.6) OScodename="Snow Leopard";;
    10.5) OScodename="Leopard";;
    10.4) OScodename="Tiger";;
    10.3) OScodename="Panther";;
    10.2) OScodename="Jaguar";;
    10.1) OScodename="Puma";;
    10.0) OScodename="Cheetah";;
  esac
  HWdevice=${SYSplatform//,/.}
  HWrelease=""                   # Unknown on OSX
  # OSX HW Quieries - 'sysctl -n' return value, 'sysctl -a | grep cpu' see params
  CPUname=$(sysctl -n machdep.cpu.brand_string) # "Intel(R) Xeon(R) CPU E5-1620 v2 @ 3.70GHz"
    CPUname=${CPUname//(R)/} # remove ALL occurences of '(R)'
    CPUname=${CPUname/" CPU"/}
    CPUname=${CPUname%' @'*} # remove speed
  CPUspeed=$(sysctl -n hw.cpufrequency_max) # get CPU speed "hw.cpufrequency_max: 3700000000"
    CPUspeed=$((CPUspeed / 1000000))
    CPUspeedBig=$((CPUspeed / 1000))
    CPUspeedSmall=$((CPUspeed % 1000))
    CPUspeed="${CPUspeedBig}.${CPUspeedSmall:0:1} GHz"
  CPUcores=$(sysctl -n hw.ncpu) # get CPU cores "hw.ncpu: 8"
  MEMraw=$(sysctl -n hw.memsize)  # "hw.memsize: 34359738368"
    MEMraw=$((MEMraw / 1024))
    MEMraw=$((MEMraw / 1024))
    MEMraw=$((MEMraw / 1024))
    MEMsize="${MEMraw}"   # SUFFIX ADDED after calculation BELOW
  MEMfree=$(vm_stat | grep 'wired')
    MEMfree=${MEMfree#*':'} # remove 'pages wired down:'
    MEMfree=${MEMfree%'.'*} # remove '.' at right side
    MEMfree=${MEMfree// /}  # remove all spaces
    MEMfree=$((MEMfree / 262144)) # multiple # pages by 4096 bytes per pages
    MEMused=$((MEMsize - MEMfree))
    MemRatio=$(( (MEMused * 100) / MEMsize))
  printf -v MEMusage "%s/%s GB (%.0f%%)" ${MEMused} ${MEMsize} ${MemRatio}
  MEMsize="${MEMraw} GB"  # FINAL NOW - add 'GB' after using it to make MEMusage variable
  DISKusage=$(df -h | awk '$NF=="/"{printf "%d/%d GB (%s)\n", $3,$2,$5}')
  return 0
}

printReportTitle () {
  display_ver
  echo -en "${CLRwhite}  -  ${REPORTTITLE}"
  case ${mode} in
    DEBUG) echo -en "  ${CLRheading2}(DEBUG)${CLRnormal}";;
    FORCE) echo -en "  ${CLRheading2}(FORCED 'UNKNOWN')${CLRnormal}";;
    NET)   echo -en "  ${CLRheading}(NETWORK)${CLRnormal}";;
    *)     ;;
  esac
  echo -e "\n"
  return 0
}

printBashVars () {
  echo -e "\t${CLRheading}BASH VARS"
  echo -e "\t${CLRtitle}HOST = \t\t${CLRwhite}${MACHINE_NAME}"
  echo -e "\t${CLRtitle}OS = \t\t${CLRwhite}${OS}"
  echo -e "\t${CLRtitle}OS-TYPE =\t${CLRwhite}${OSTYPE}${CLRnormal}\n"
  return 0
}

printSystemVars () {
  echo -e "\t${CLRheading}UNAME${CLRwhite}"
  echo -e "\t${CLRtitle}SYSkernal = \t${CLRwhite}${SYSkernal}"
  echo -e "\t${CLRtitle}SYSkernalVer = \t${CLRwhite}${SYSkernalVer}"
  echo -e "\t${CLRtitle}SYSmachine = \t${CLRwhite}${SYSmachine}"
  echo -e "\t${CLRtitle}SYSplatform = \t${CLRwhite}${SYSplatform}\n"
  if [[ "$LSBset" == "TRUE" ]]; then   # only print if LSB installed
    echo -e "\t${CLRheading}LSB_RELEASE${CLRwhite}"
    echo -e "\t${CLRtitle}LSBdescr = \t${CLRwhite}${LSBdescr}"
    echo -e "\t${CLRtitle}LSBid = \t${CLRwhite}${LSBid}"
    echo -e "\t${CLRtitle}LSBrel = \t${CLRwhite}${LSBrel}"
    echo -e "\t${CLRtitle}LSBcodename = \t${CLRwhite}${LSBcodename}${CLRnormal}\n"
  fi
  return 0
}

printDebugRPI() {
  echo -e "\t${CLRheading}RPI VARS"
  echo -e "\t${CLRtitle}RPi HW Rev =\t${CLRwhite}${RPIrev}"
  echo -e "\t${CLRtitle}RPi Model =\t${CLRwhite}${RPImodel}"
  echo -e "\t${CLRtitle}RPi Rel Date =\t${CLRwhite}${RPIrel}"
  echo -e "\t${CLRtitle}RPi Manuf =\t${CLRwhite}${RPIman}${CLRnormal}\n"
  return 0
}

printDebugOSX() {
  echo -e "\t${CLRheading}OSX VARS"
  echo -e "\t${CLRtitle}Main V Init = \t${CLRwhite}${OSXinitialVer}"
  echo -e "\t${CLRtitle}Main V Adj = \t${CLRwhite}${OSXadjustedVer}"
  echo -e "\t${CLRtitle}OSX Ver = \t${CLRwhite}${OSXmainVer}"
  echo -e "\t${CLRtitle}OSX sub V = \t${CLRwhite}${OSXsubVer}${CLRnormal}\n"
  return 0
}

printDebugReport() {
  printReportTitle
  printBashVars
  printSystemVars
    [[ "$DeviceType" == "RPI" ]] && printDebugRPI
    [[ "$DeviceType" == "OSX" ]] && printDebugOSX
  return 0
}

printReportNetwork() {
  printReportTitle
  echo -e "\t${CLRheading}HOST\t\t${CLRheading2}${MACHINE_NAME}"
  [[ -n $SYSnode ]] && [[ "$SYSnode" != "$HOSTNAME" ]] && echo -e "\t${CLRheading}NODE\t\t${CLRheading2}${SYSnode}"
  if [[ $lanIP != "Unknown" ]]; then
    for (( i=0; i<count; i=i+1 )); do
      lanIP=${lanIPS[i]}
      echo -e "\t${CLRtitle}LAN IP \t\t${CLRwhite}${lanIP}"
    done
  fi
  [[ -n pubIP ]] && echo -e "\t${CLRtitle}Internet IP \t${CLRwhite}${pubIP}${CLRnormal}\n"
  return 0
}

printReportSystem() {
  echo -e "\t${CLRheading}OS\t\t${CLRheading2}${OSfullname}"
  [[ -n $OScodename ]] && echo -e "\t${CLRtitle}CODENAME\t${CLRwhite}${OScodename}"
  [[ -n $OSVERsion ]] && echo -e "\t${CLRtitle}OS VERSION\t${CLRwhite}${OSVERsion}"
  echo -e "\n\t${CLRheading}DEVICE\t\t${CLRheading2}${HWdevice}"
  [[ -n $HWrelease ]] && echo -e "\t${CLRtitle}RELEASE DATE\t${CLRwhite}${HWrelease}"
  [[ -n $CPUname ]] && echo -e "\t${CLRtitle}PROCESSOR\t${CLRwhite}${CPUname}"
  [[ -n $CPUspeed ]] && echo -e "\t${CLRtitle}CPU SPEED\t${CLRwhite}${CPUspeed}"
  [[ -n $CPUcores ]] && echo -e "\t${CLRtitle}CPU CORES\t${CLRwhite}${CPUcores}"
  [[ -n $MEMsize ]] && echo -e "\t${CLRtitle}MEMORY\t\t${CLRwhite}${MEMsize}"
  [[ -n $MEMusage ]] && echo -e "\t${CLRtitle}MEM USAGE\t${CLRwhite}${MEMusage}"
  [[ -n $DISKusage ]] && echo -e "\t${CLRtitle}DISK USAGE\t${CLRwhite}${DISKusage}$CLRnormal"
  echo
  return 0
}

printMainReport() {
  printReportNetwork
  if [[ -z "$DeviceType" ]] || [[ "$mode" == "FORCE" ]]; then # unknown device OR forced
    OSVERsion=${SYSkernalVer}  # set VARS to raw data
    CPUname=${SYSmachine}
    [[ "$SYSplatform" != "unknown" ]] && HWdevice=${SYSplatform}  # Don't set if 'unknown'
  fi
  printReportSystem
  return 0
}


######################################################################
#     EXECUTION STARTS HERE
######################################################################

### INITIALIZATION FUNCTIONS
  processCommandTail "$@"    # CHECK FOR PASSED PARAMETERS

### GATHER INFO
  gatherPUBLICip
  gatherLANip

  [[ $mode == "NET" ]] && printReportNetwork && processExit

  gatherSYSinfo
  gatherARCHinfo
  gatherLSBinfo

### PROCESS DEVICE-SPECIFIC INFO
  if [[ "$OS" == "Linux" ]]; then
    if ([[ "$PROCarch" == "armhf" ]] || [[ $SYSmachine == armv* ]] || [[ "$OSTYPE" == "linux-gnueabihf" ]]); then
      setRPIvars
    else
      setLINUXvars
    fi
  elif [[ "$OS" == "Darwin" ]]; then
    setOSXvars
  else                 # Unknown device
    setNOTOSXvars
  fi

### PRINT REPORT
  [[ "$mode" == "DEBUG" ]] && printDebugReport && processExit
  printMainReport

### EXIT SCRIPT
  processExit

### SHOULD NEVER RUN CODE BELOW THIS LINE
echo "ERROR - exit function didnt work" >&2
exit 2
