#!/usr/bin/env bash

# sysis - Display Key System Information
#
#     Lightweight Cross-Platform Utility for:
#         macOS, Linux, and Windows 10 Bash on Windows
#
#    from: https://github.com/robertpeteuil/sysis
#
#  Author: Robert Peteuil   @RobertPeteuil
#

scriptname="sysis"
scriptbuildnum="3.5.2"
scriptbuilddate="2017-10-17"

############################################################
### VARS INITS

OS=$(uname -s)
MACHINE_NAME=$(hostname -s)

# VARIABLES - OTHER
REPORTTITLE="System Information"
EXITSTATUS=0
EXITMESSAGE=""


############################################################
###     PRE-EXECUTION

# turn on color if possible
if test -t 1; then            # check if stdout is a terminal
  if [ "$TERM" == "xterm-new" ]; then
    TERM="xterm"
  fi
  ncolors=$(tput colors)    # see if it supports colors
  if test -n "$ncolors" && test "$ncolors" -ge 8; then
    # Set Colors
    bold="$(tput bold)"
    red="$(tput setaf 1)"
    green="$(tput setaf 2)"
    yellow="$(tput setaf 3)"
    blue="$(tput setaf 4)"
    magenta="$(tput setaf 5)"
    cyan="$(tput setaf 6)"
    white="$(tput setaf 7)"
    # set color theme vars to allow for quick changing
    CLRnormal="\033[0m"
    CLRwhite=${bold}${white}
    CLRheading=${bold}${blue}
    CLRheading2=${bold}${green}
    CLRtitle=${bold}${cyan}
    CLRtitle2=${bold}${magenta}
    CLRsuccess=${bold}${green}
    CLRwarning=${bold}${yellow}
    CLRerror=${bold}${red}
  fi
fi


######################################################################
#     FUNCTIONS
######################################################################

processExit () {    # error message can be sent to function when calling
  local var="$*"
  if [[ -n "$EXITMESSAGE" ]]; then
    echo -e "$EXITMESSAGE" >&2
  fi
  if [[ -n "$var" ]]; then                    # if error-text was passed
    echo -e "$var" >&2                        #   display it on std-error
    [[ "$EXITSTATUS" == 0 ]] && EXITSTATUS=1  #   set exit-status to at least 1
  fi
  exit $EXITSTATUS
}

processAbort () {
  local var=$*
  [[ -n $var ]] && EXITMESSAGE="${CLRerror}ABORT${CLRwhite} - ${var}${CLRnormal}"
  EXITSTATUS=2
  processExit
}

displayVer() {
  echo -en "${CLRheading2}${scriptname}${CLRwhite}  ver ${CLRtitle}${scriptbuildnum} ${CLRwhite}- ${CLRtitle}${scriptbuilddate}${CLRwhite}${CLRnormal}"
}

printHelp() {
  displayVer
  echo -e "\n${CLRwhite}Collect and print information on system, network and OS to standard output.\n"
  echo -e "${CLRtitle}usage: ${CLRwhite}${scriptname} ${CLRtitle2}[OPTIONS] [DEBUG]${CLRwhite}\n"
  echo -e "${CLRtitle}   OPTIONS"
  echo -e "${CLRtitle2}     -d\t${CLRwhite}: debug only report"
  echo -e "${CLRtitle2}     -n\t${CLRwhite}: network only report"
  echo -e "${CLRtitle2}     -h\t${CLRwhite}: help"
  echo -e "${CLRtitle2}     -V\t${CLRwhite}: version info"
  echo -e "${CLRtitle2} --help\t${CLRwhite}: detailed help${CLRnormal}"
  if [[ "$1" ]]; then
    echo
    echo -e "${CLRtitle}   DEBUG"
    echo -e "${CLRtitle2}--force\t${CLRwhite}: force report as 'unknown' type"
    echo
    echo -e "${CLRtitle}   EXIT STATUS"
    echo -e "${CLRtitle2}      0   ${CLRwhite}if OK,"
    echo -e "${CLRtitle2}      1   ${CLRwhite}if minor problems (e.g., cannot access subdirectory),"
    echo -e "${CLRtitle2}      2   ${CLRwhite}if serious trouble (e.g., cannot access command-line argument).${CLRnormal}"
  fi
  processExit
}

getCommandTail() {
  while [[ -n $1 ]]; do
    case $1 in
      -d)           mode="DEBUG";;
      -n)           mode="NET";;
      -h)           printHelp;;
      -V)           displayVer; echo; processExit;;
      --help)       printHelp FULL;;
      --force)      mode="FORCE";;
      *)            printHelp;;
    esac
    shift
  done
  return 0
}

cleanText() {
    local var=$*
    var="${var%"${var##*[![:space:]]}"}"    # remove leading whitespace
    var="${var#"${var%%[![:space:]]*}"}"    # remove trailing whitespace
    echo -n "$var"
}

cleanCPUname() {
  local tempCPUname=$1
  tempCPUname=${tempCPUname#*': '}          # strip left of ': '
  tempCPUname=${tempCPUname//'(R)'/}        # remove '(R)'
  tempCPUname=${tempCPUname//'(tm)'/}       # remove '(tm)'
  tempCPUname=${tempCPUname//'(TM)'/}        # remove '(TM)'
  tempCPUname=${tempCPUname//' CPU'/}        # remove ' CPU'
  tempCPUname=${tempCPUname//' Processor'/}  # remove ' Processor'
  tempCPUname=${tempCPUname%' @'*}          # remove speed
  tempCPUname=${tempCPUname%' v'*}          # remove version #
  tempCPUname=${tempCPUname%'  '*}          # remove model # that comes after 2 spaces
  tempCPUname=${tempCPUname//' 0'/}         # remove space 0
  tempCPUname=$(cleanText "$tempCPUname")   # remove leading / trailine space
  # at this point CPU MIGHT include model # P7350 or E5-1620
  #   removed below since its not consistently present
  tempCPUname=$(echo "$tempCPUname" | awk '{sub(/\s[[:alpha:]][[:alpha:]]?[0-9]{4}$/, ""); print $0}')  # remove processor rev P(A)XXXX ex: P47350
  tempCPUname=$(echo "$tempCPUname" | awk '{sub(/\s[[:alpha:]][[:alpha:]]?[0-9]-[0-9]{4}$/, ""); print $0}')  # remove processor rev P(A)5-XXXX ex: E5-1620
  echo -n "$tempCPUname"
}

cleanVARtext() {
  local unclearVARtext=$1
  unclearVARtext=${unclearVARtext#*':'}     # strip left of ':'
  unclearVARtext=${unclearVARtext%%'.'*}    # strip right of '.'
  unclearVARtext=${unclearVARtext// /}      # remove spaces
  echo -n "$unclearVARtext"
}

getNetwork() {
  pubIP=$(curl -s ipinfo.io/ip)  # Internet IP
  if [[ $(ip -4 address 2> /dev/null) ]]; then  # LANIP via 'ip' if possible
    lanIP=$(ip -4 address | awk '/brd/ {split($2, ip, /\//); print ip[1]}')
  elif [[ $(ifconfig -a 2> /dev/null) ]]; then  # else try 'ifconfig'
    case $OS in
     Linux)   # note RPI only has awk 1.x installed
        lanIP=$(ifconfig -a | awk '/(cast)/ {print $2}' | cut -d: -f2)
        ;;
     Darwin)  # filters virtual adapters (those with limited scope broadcast)
        lanIP=$(ifconfig -a | awk '/(cast).([0-9]{1,3}\.){2}1\./ {print $2}')
        ;;
     FreeBSD|OpenBSD)
        lanIP=$(ifconfig | grep -E 'inet.[0-9]' | grep -v '127.0.0.1' | awk '{print $2}')
        ;;
     SunOS)
        lanIP=$(ifconfig -a | grep inet | grep -v '127.0.0.1' | awk '{print $2}')
        ;;
     *)
        lanIP="Unknown"
        ;;
    esac
  fi
  if [[ -n $lanIP ]]; then  # if multi LanIPs put in array
    count=0
    for i in $lanIP; do
      lanIPS[count]=$i
      ((++count))
    done
  fi
  return 0
}

getSystem() {
  if [[ $(uname 2> /dev/null) ]]; then
  	SYSnode=$(uname -n 2> /dev/null)
  	SYSkernal=$(uname -s 2> /dev/null)
  	SYSkernalVer=$(uname -r 2> /dev/null)
  	SYSmachine=$(uname -m 2> /dev/null)
  	SYSplatform=$(uname -i 2> /dev/null)
  else
    processExit "cannot execute ${CLRwarning}'uname'${CLRwhite}"
  fi
  if [[ $(dpkg --help 2> /dev/null) ]]; then
    PROCarch=$(dpkg --print-architecture)
  fi
  if [ -r /etc/os-release ]; then
    VALUESvia="FILE"
    LSBrel="$(. /etc/os-release && echo "$PRETTY_NAME")"
    LSBcodename="$(. /etc/os-release && echo "$VERSION")"
    LSBcodename=${LSBcodename#*', '}
    LSBcodename=${LSBcodename#* (}
    LSBcodename=${LSBcodename%)}
  elif [[ $(lsb_release -h 2> /dev/null) ]]; then
    VALUESvia="LSB"
    LSBidPRE=$(lsb_release -i 2> /dev/null)
    LSBrelPRE=$(lsb_release -r 2> /dev/null)
    LSBcodenamePRE=$(lsb_release -c 2> /dev/null)
  	[[ -n $LSBidPRE ]] && LSBid=${LSBidPRE#*":"} && LSBid=$(cleanText "$LSBid")
  	[[ -n $LSBrelPRE ]] && LSBrel=${LSBrelPRE#*":"} && LSBrel=$(cleanText "$LSBrel")
  	[[ -n $LSBcodenamePRE ]] && LSBcodename=${LSBcodenamePRE#*":"} && LSBcodename=$(cleanText "$LSBcodename")
  fi
  return 0
}

setLinuxCommon() {
  if [[ $VALUESvia == "FILE" ]]; then   # plan a - use vals from file
    OSfullname="${LSBrel}"
    OScodename="${LSBcodename}"
  elif [[ $VALUESvia == "LSB" ]]; then  # plan b - use vals from lsb_release
    OSfullname="${LSBid} ${LSBrel}"
    OScodename="${LSBcodename}"
  else                                  # plan c - get OS name from uname
    OSfullname="${SYSkernal}"
  fi
  if [ -e "/sys/devices/system/cpu/possible" ]; then
    DEVICEinfoExists=true
    if lscpu | grep -q -m1 'max MHz'; then
      CPUspeed=$(lscpu | grep -m1 'max MHz')  # exists on adj proc
    else
      CPUspeed=$(lscpu | grep -m1 'MHz')
    fi
    CPUspeed=$(cleanVARtext "$CPUspeed")
    CPUspeed=$((CPUspeed + 5))  # add 5 to avoid rounding errors
    CPUspeedBig=$((CPUspeed / 1000))
    CPUspeedSmall=$((CPUspeed % 1000))
    CPUcores=$(lscpu | grep 'Core(s)')
    CPUcores=$(cleanVARtext "$CPUcores")
    CPUinfo="${CPUspeedBig}.${CPUspeedSmall:0:1} GHz ${CLRnormal}${CLRwarning}(${CPUcores} Core)${CLRnormal}"
    # Pre-color version
    # CPUinfo="${CPUspeedBig}.${CPUspeedSmall:0:1} GHz (${CPUcores} Core)"
  fi
  if [[ $(df 2> /dev/null) ]]; then
    DEVICEinfoExists=true
    DISKuse=$(df -h | awk '$NF=="/"{printf "%d/%d GB", $3,$2}')
    DISKRatio=$(df -h | awk '$NF=="/"{printf "%s\n", $5}')
    DISKusage="${DISKuse} ${CLRnormal}${CLRwarning}(${DISKRatio})${CLRnormal}"
    # Pre-color version
    # DISKusage=$(df -h | awk '$NF=="/"{printf "%d/%d GB (%s)\n", $3,$2,$5}')
  fi
  return 0
}

setRPI() {
  DeviceType="RPI"
  OSdetails="KERNEL\t"
  setLinuxCommon
  if [ -e "/proc/cpuinfo" ]; then
    DEVICEinfoExists=true
    RPIrev=$(awk '/Revision/ { sub(/^.+\:/, "") ; print $1 }' /proc/cpuinfo)
    CPUname=$(awk '/model\ name/ { sub(/-compatible/, ""); print ($4)" r"($7); exit}' /proc/cpuinfo)
    # RPI HW version source: http://elinux.org/RPi_HardwareHistory
    case "$RPIrev" in
        *beta) RPImodel="Beta"; RPIman="Beta"; RPIrel="Q1 2012";;
        *002) RPImodel="B (1.0)"; RPIman="unknown"; RPIrel="Q1 2012";;
        *003) RPImodel="B (1.0)"; RPIman="ECN 001"; RPIrel="Q3 2012";;
        *004) RPImodel="B (2.0)"; RPIman="Sony"; RPIrel="Q3 2012";;
        *005) RPImodel="B (2.0)"; RPIman="Qisda"; RPIrel="Q4 2012";;
        *006) RPImodel="B (2.0)"; RPIman="Egoman"; RPIrel="Q4 2012";;
        *007) RPImodel="A (2.0)"; RPIman="Egoman"; RPIrel="Q1 2013";;
        *008) RPImodel="A (2.0)"; RPIman="Sony"; RPIrel="Q1 2013";;
        *009) RPImodel="A (2.0)"; RPIman="Qisda"; RPIrel="Q1 2013";;
        *00d) RPImodel="B (2.0)"; RPIman="Egoman"; RPIrel="Q4 2012";;
        *00e) RPImodel="B (2.0)"; RPIman="Sony"; RPIrel="Q4 2012";;
        *00f) RPImodel="B (2.0)"; RPIman="Qisda"; RPIrel="Q4 2012";;
        *010) RPImodel="B+ (1.0)"; RPIman="Sony"; RPIrel="Q3 2014";;
        *011) RPImodel="Compute Module"; RPIman="Sony"; RPIrel="Q2 2014";;
        *012) RPImodel="A+ (1.0)"; RPIman="Sony"; RPIrel="Q4 2014";;
        *013) RPImodel="B+ (1.2)"; RPIman="Embest"; RPIrel="Q1 2015";;
        *014) RPImodel="Compute Module"; RPIman="Sony"; RPIrel="Q1 2015";;
        *015) RPImodel="A+ (1.0)"; RPIman="Sony"; RPIrel="Q1 2015";;
        *a01040) RPImodel="2B (1.0)"; RPIman="Sony"; RPIrel="Unknown";;
        *a01041) RPImodel="2B (1.1)"; RPIman="Sony"; RPIrel="Q1 2015";;
        *a21041) RPImodel="2B (1.1)"; RPIman="Embest"; RPIrel="Q1 2015";;
        *a22042) RPImodel="2B (1.2)"; RPIman="Embest"; RPIrel="Q3 2016";;
        *900021) RPImodel="A+ (1.1)"; RPIman="Sony"; RPIrel="Q3 2016";;
        *900032) RPImodel="B+ (1.2)"; RPIman="Sony"; RPIrel="Q2 2016";;
        *900092) RPImodel="Zero (1.2)"; RPIman="Sony"; RPIrel="Q4 2015";;
        *900093) RPImodel="Zero (1.3)"; RPIman="Embest"; RPIrel="Q4 2016";;
        *9000c1) RPImodel="Zero W (1.1)"; RPIman="Sony"; RPIrel="Q1 2017";;
        *a02082) RPImodel="3B (1.2)"; RPIman="Sony"; RPIrel="Q1 2016";;
        *a020a0) RPImodel="Compute Module 3"; RPIman="Sony"; RPIrel="Q1 2017";;
        *a22082) RPImodel="3B (1.2)"; RPIman="Embest"; RPIrel="Q1 2016";;
        *a32082) RPImodel="3B (1.2)"; RPIman="Sony"; RPIrel="Q4 2016";;
        *) RPImodel="'Unknown Version'"; RPIman="Unknown"; RPIrel="Unknown";;
    esac
    HWrelease="${RPIrel} (${RPIman})"
  else   # RPI Model not known
    RPImodel="'Unknown Version'"
  fi
  OSversion=${SYSkernalVer%"-"*}
  HWdevice="Raspberry Pi ${RPImodel}"
  CPUmeta="${CPUname} ${CPUinfo}"
  if [[ $(free 2> /dev/null) ]]; then
    DEVICEinfoExists=true
    MEMuse=$(free -m | awk 'NR==2{printf "%s/%s MB", $3,$2 }')
    MemRatio=$(free -m | awk 'NR==2{printf "%.0f\n", $3*100/$2 }')
    MEMusage="${MEMuse} ${CLRnormal}${CLRwarning}(${MemRatio}%)${CLRnormal}"
    # Pre-color version
    # MEMusage=$(free -m | awk 'NR==2{printf "%s/%s MB (%d%%)\n", $3,$2,$3*100/$2 }')
  fi
  return 0
}

setLinux() {
  DeviceType="Linux"
  OSdetails="KERNEL\t"
  setLinuxCommon
  OSversion=${SYSkernalVer%"-"*}
  HWdevice=""
  HWrelease=""
  if [ -e "/proc/cpuinfo" ]; then
    DEVICEinfoExists=true
    CPUname=$(grep -m1 'model name' < /proc/cpuinfo)
    CPUname=$(cleanCPUname "$CPUname")
  fi
  CPUmeta="${CPUname} ${CPUinfo}"
  if [[ $(free 2> /dev/null) ]]; then
    DEVICEinfoExists=true
    # no longer used:
    # MEMsizeMB=$(free -m | awk '/^Mem:/{print $2}')
    MEMuse=$(free -m | awk 'NR==2{printf "%s/%s MB", $3,$2 }')
    MemRatio=$(free -m | awk 'NR==2{printf "%.0f\n", $3*100/$2 }')
    MEMusage="${MEMuse} ${CLRnormal}${CLRwarning}(${MemRatio}%)${CLRnormal}"
    # Pre-color version
    # MEMusage=$(free -m | awk 'NR==2{printf "%s/%s MB (%.0f%%)\n", $3,$2,$3*100/$2 }')
  fi
  return 0
}

setMac() {
  DeviceType="Mac"
  OSdetails="OS VERSION"
  DEVICEinfoExists=true
  MacOSinitialVer=${SYSkernalVer%%.*}
  MacOSadjustedVer=$((MacOSinitialVer-4))
  MacOSsubVer=${SYSkernalVer%.*}
  MacOSsubVer=${MacOSsubVer#*.}
  MacOSmainVer="10.${MacOSadjustedVer}"
  OSversion="10.${MacOSadjustedVer}.${MacOSsubVer}"
  OSfullname="macOS ${MacOSmainVer}"
  case $MacOSmainVer in
    10.13) OScodename="High Sierra";;
    10.12) OScodename="Sierra";;
    10.11) OScodename="El Capitan";;
    10.10) OScodename="Yosemite";;
    10.9) OScodename="Mavericks";;
    10.8) OScodename="Mountain Lion";;
    10.7) OScodename="Lion";;
    10.6) OScodename="Snow Leopard";;
    10.5) OScodename="Leopard";;
    10.4) OScodename="Tiger";;
    10.3) OScodename="Panther";;
    10.2) OScodename="Jaguar";;
    10.1) OScodename="Puma";;
    10.0) OScodename="Cheetah";;
  esac
  HWdevice=${SYSplatform//,/.}
  HWrelease=""
  # Mac HW Quieries - 'sysctl -n' return string with item and value
  CPUname=$(sysctl -n machdep.cpu.brand_string)
  CPUname=$(cleanCPUname "$CPUname")
  CPUspeed=$(sysctl -n hw.cpufrequency_max)
    CPUspeed=$((CPUspeed / 1000000))
  CPUspeedBig=$((CPUspeed / 1000))
  CPUspeedSmall=$((CPUspeed % 1000))
  CPUcores=$(sysctl -n hw.ncpu)
  CPUinfo="${CPUspeedBig}.${CPUspeedSmall:0:1} GHz ${CLRnormal}${CLRwarning}(${CPUcores} Core)${CLRnormal}"
  # Pre-color version
  # CPUinfo="${CPUspeedBig}.${CPUspeedSmall:0:1} GHz (${CPUcores} Core)"
  CPUmeta="${CPUname} ${CPUinfo}"
  MEMsizeMB=$(sysctl -n hw.memsize)
    MEMsizeMB=$((MEMsizeMB / (1024 * 1024) ))    # Mem in MB
  #  Memory used = App Use + Wired use + Compressed use
  MEMusedApps=$(vm_stat | grep 'active')
    MEMusedApps=$(cleanVARtext "$MEMusedApps")
    MEMusedApps=$((MEMusedApps / 256))
  MEMusedWired=$(vm_stat | grep 'wired')
    MEMusedWired=$(cleanVARtext "$MEMusedWired")
    MEMusedWired=$((MEMusedWired / 256))
  MEMusedComp=$(vm_stat | grep 'occupied by compressor')
    MEMusedComp=$(cleanVARtext "$MEMusedComp")
    MEMusedComp=$((MEMusedComp / 256))
  MEMused=$((MEMusedApps + MEMusedWired + MEMusedComp))
  MemRatio=$(( (MEMused * 100) / MEMsizeMB))
  printf -v MEMusage "%s/%s MB" ${MEMused} ${MEMsizeMB}
  # printf -v MEMusage "%s/%s MB (%.0f%%)" ${MEMused} ${MEMsizeMB} ${MemRatio}
  MEMusage="${MEMusage} ${CLRnormal}${CLRwarning}(${MemRatio}%)${CLRnormal}"
  DISKuse=$(df -h | awk '$NF=="/"{printf "%d/%d GB", $3,$2}')
  DISKRatio=$(df -h | awk '$NF=="/"{printf "%s\n", $5}')
  DISKusage="${DISKuse} ${CLRnormal}${CLRwarning}(${DISKRatio})${CLRnormal}"
  # Pre-color version
  # DISKusage=$(df -h | awk '$NF=="/"{printf "%d/%d GB (%s)\n", $3,$2,$5}')
  return 0
}

printTitle () {
  displayVer
  echo -en "${CLRwhite}  -  ${REPORTTITLE}"
  case ${mode} in
    DEBUG) echo -en "  ${CLRheading2}(DEBUG)${CLRnormal}";;
    FORCE) echo -en "  ${CLRheading2}(FORCED 'UNKNOWN')${CLRnormal}";;
    NET)   echo -en "  ${CLRheading}(NETWORK)${CLRnormal}";;
    *)     ;;
  esac
  echo -e "\n"
  return 0
}

reportDebug() {
  printTitle
  echo -e "\t${CLRheading}BASH VARS${CLRnormal}"
  echo -e "\t${CLRtitle}HOST = \t\t${CLRwhite}${MACHINE_NAME}${CLRnormal}"
  echo -e "\t${CLRtitle}OS = \t\t${CLRwhite}${OS}${CLRnormal}"
  echo -e "\t${CLRtitle}OS-TYPE =\t${CLRwhite}${OSTYPE}${CLRnormal}${CLRnormal}\n"
  echo -e "\t${CLRheading}UNAME${CLRwhite}${CLRnormal}"
  echo -e "\t${CLRtitle}SYSkernal = \t${CLRwhite}${SYSkernal}${CLRnormal}"
  echo -e "\t${CLRtitle}SYSkernalVer = \t${CLRwhite}${SYSkernalVer}${CLRnormal}"
  echo -e "\t${CLRtitle}SYSmachine = \t${CLRwhite}${SYSmachine}${CLRnormal}"
  echo -e "\t${CLRtitle}SYSplatform = \t${CLRwhite}${SYSplatform}${CLRnormal}\n"
  if [[ "$VALUESvia" == "FILE" ]]; then
    echo -e "\t${CLRheading}/ETC/OS-RELEASE${CLRwhite}${CLRnormal}"
    echo -e "\t${CLRtitle}LSBrel = \t${CLRwhite}${LSBrel}${CLRnormal}"
    echo -e "\t${CLRtitle}LSBcodename = \t${CLRwhite}${LSBcodename}${CLRnormal}\n"
  elif [[ "$VALUESvia" == "LSB" ]]; then
    echo -e "\t${CLRheading}LSB_RELEASE${CLRwhite}${CLRnormal}"
    echo -e "\t${CLRtitle}LSBid = \t${CLRwhite}${LSBid}${CLRnormal}"
    echo -e "\t${CLRtitle}LSBrel = \t${CLRwhite}${LSBrel}${CLRnormal}"
    echo -e "\t${CLRtitle}LSBcodename = \t${CLRwhite}${LSBcodename}${CLRnormal}\n"
  fi
  if [[ "$DeviceType" == "RPI" ]]; then
    echo -e "\t${CLRheading}RPI VARS"
    echo -e "\t${CLRtitle}RPi HW Rev =\t${CLRwhite}${RPIrev}${CLRnormal}"
    echo -e "\t${CLRtitle}RPi Model =\t${CLRwhite}${RPImodel}${CLRnormal}"
    echo -e "\t${CLRtitle}RPi Rel Date =\t${CLRwhite}${RPIrel}${CLRnormal}"
    echo -e "\t${CLRtitle}RPi Manuf =\t${CLRwhite}${RPIman}${CLRnormal}\n"
  elif [[ "$DeviceType" == "Mac" ]]; then
    echo -e "\t${CLRheading}MacOS VARS"
    echo -e "\t${CLRtitle}Raw Version = \t${CLRwhite}${MacOSinitialVer}${CLRnormal}"
    echo -e "\t${CLRtitle}Adj Version = \t${CLRwhite}${MacOSadjustedVer}${CLRnormal}"
    echo -e "\t${CLRtitle}MacOS Ver = \t${CLRwhite}${MacOSmainVer}${CLRnormal}"
    echo -e "\t${CLRtitle}MacOS sub V = \t${CLRwhite}${MacOSsubVer}${CLRnormal}\n"
  fi
  return 0
}

reportNetwork() {
  # printTitle
  echo -e "\t${CLRheading}HOST\t\t${CLRheading2}${MACHINE_NAME}"
  [[ -n $SYSnode ]] && [[ "$SYSnode" != "$HOSTNAME" ]] && echo -e "\t${CLRheading}NODE\t\t${CLRheading2}${SYSnode}"
  if [[ $lanIP != "Unknown" ]]; then
    for (( i=0; i<count; i=i+1 )); do
      lanIP=${lanIPS[i]}
      echo -e "\t${CLRtitle}LAN IP \t\t${CLRwhite}${lanIP}"
    done
  fi
  [[ -n $pubIP ]] && echo -e "\t${CLRtitle}Internet IP \t${CLRwhite}${pubIP}${CLRnormal}\n"
  return 0
}

reportSystem() {
  [[ -n $OSfullname ]] && echo -e "\t${CLRheading}OS\t\t${CLRheading2}${OSfullname}${CLRnormal}"
  [[ -n $OScodename ]] && echo -e "\t${CLRtitle}CODENAME\t${CLRwhite}${OScodename}${CLRnormal}"
  [[ -n $OSversion ]] && echo -e "\t${CLRtitle}${OSdetails}\t${CLRwhite}${OSversion}${CLRnormal}"
  if [ $DEVICEinfoExists ]; then
    echo
    if [[ -n $HWdevice ]]; then
      echo -e "\t${CLRheading}DEVICE\t\t${CLRheading2}${HWdevice}${CLRnormal}"
      CLRsubsect1=${CLRtitle}
      CLRsubsect2=${CLRwhite}
    else
      CLRsubsect1=${CLRheading}
      CLRsubsect2=${CLRheading2}
    fi
    [[ -n $HWrelease ]] && echo -e "\t${CLRtitle}RELEASE DATE\t${CLRwhite}${HWrelease}${CLRnormal}"
    [[ -n $CPUmeta ]] && echo -e "\t${CLRsubsect1}CPU\t\t${CLRsubsect2}${CPUmeta}${CLRnormal}"
    # [[ -n $CPUmeta ]] && echo -e "\t${CLRtitle}CPU\t\t${CLRwhite}${CPUmeta}"
    # [[ -n $CPUname ]] && echo -e "\t${CLRtitle}PROCESSOR\t${CLRwhite}${CPUname}"
    # [[ -n $CPUinfo ]] && echo -e "\t${CLRtitle}CPU INFO\t${CLRwhite}${CPUinfo}"
    [[ -n $MEMusage ]] && echo -e "\t${CLRtitle}MEM USAGE\t${CLRwhite}${MEMusage}${CLRnormal}"
    [[ -n $DISKusage ]] && echo -e "\t${CLRtitle}DISK USAGE\t${CLRwhite}${DISKusage}${CLRnormal}"
  fi
  return 0
}

reportMain() {
  reportNetwork
  if [[ -z "$DeviceType" ]] || [[ "$mode" == "FORCE" ]]; then
    # set VARS to most raw form
    OSversion=${SYSkernalVer}
    CPUname=${SYSmachine}
    [[ "$SYSplatform" != "unknown" ]] && HWdevice=${SYSplatform}
  fi
  reportSystem
  echo
  return 0
}


######################################################################
#     EXECUTION STARTS HERE
######################################################################

getCommandTail "$@"

getNetwork
[[ $mode == "NET" ]] && reportNetwork && processExit
getSystem

if [[ "$OS" == "Linux" ]]; then
  if ([[ "$PROCarch" == "armhf" ]] || [[ $SYSmachine == armv* ]] || [[ "$OSTYPE" == "linux-gnueabihf" ]]); then
    setRPI                          # Some Linux common extraction + RPi unique
  else
    setLinux                        # Use linux common + linux defaults)
  fi
elif [[ "$OS" == "Darwin" ]]; then  # Mac unique extraction
  setMac
else                                # un-determined host type
  processExit "${CLRerror}Error${CLRwhite}: ${CLRwarning}Could not determine System Type${CLRwhite}"
fi

[[ "$mode" == "DEBUG" ]] && reportDebug && processExit
reportMain

processExit

### SHOULD NEVER RUN CODE BELOW THIS LINE
echo "ERROR - exit function didnt work" >&2
exit 2
